{"version":3,"sources":["Sudoku.js","utils.js","App.js","reportWebVitals.js","index.js"],"names":["Sudoku","value","style","width","height","font","border","display","position","top","color","arr","cells","i","j","push","this","renderCell","renderBlockCells","parsed","blocks","nums","k","l","renderSubBlock","renderAllBlocks","props","board","React","Component","curNumDedup","solutionsFound","solveEasyMethods","bestEffort","slice","possibilities","Array","Set","add","valueSubsets","values","length","thisSet","curVal","size","sets","rowset","colset","x","y","boxset","xx","yy","didSomething","group","valueSubset","squaresContainingOnly","square","hasExtraValue","has","delete","squaresContainingSome","hasOne","newSet","console","log","next","generateFullSudoku","grid","fill","solveSudoku","findHarderSudoku","checkedMap","Map","Math","floor","random","set","val","hasMultiSolutions","printSudoku","join","multiSolution","max2Solutions","resetMap","checkValue","u","v","isValidSudoku","cloneGrid","offset","solved","App","empty","state","loading","setState","setTimeout","sudoku","hardSudoku","generateVeryHardSudoku","className","onClick","generateNewSudoku","left","marginLeft","marginRight","margin","textAlign","href","right","bottom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.344122a9.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nclass Sudoku extends React.Component {\r\n\r\n    renderCell(value) {\r\n        return (\r\n            <div style={{\r\n                width: 50,\r\n                height: 50,\r\n                font: '37px Arial, sans-serif',\r\n                border: '1px solid black',\r\n                display: 'inline-block',\r\n            }}><div style={{\r\n                position: 'relative',\r\n                top: 6,\r\n                color: value === '-' ? 'white' : 'black',\r\n            }}>{value}</div></div>\r\n        )\r\n    }\r\n\r\n    renderBlockCells(arr) {\r\n        let cells = [];\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                cells.push(this.renderCell(arr[j + i*3]));\r\n            }\r\n            cells.push(<br/>)\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    renderSubBlock(arr) {\r\n        return (\r\n            <div style={{border: '1px solid black', display: 'inline-block'}}>{\r\n                this.renderBlockCells(arr)\r\n            }</div>\r\n        );\r\n    }\r\n\r\n    renderAllBlocks(parsed) {\r\n        let blocks = [];\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                let nums = [];\r\n                for (let k = 0; k < 3; k++) {\r\n                    for (let l = 0; l < 3; l++) {\r\n                        nums.push(parsed[(j*3+l) + (i*3+k)*9]);\r\n                    }\r\n                }\r\n                blocks.push(this.renderSubBlock(nums));\r\n            }\r\n            blocks.push(<br/>);\r\n        }\r\n        return blocks;\r\n    }\r\n    render() {\r\n        return (\r\n            <div style={{border: '1px solid black', display: 'inline-block'}}>\r\n                {this.renderAllBlocks(this.props.board)}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Sudoku;\r\n","let curNumDedup = null;\r\nlet solutionsFound = 0;\r\n\r\nexport function generateVeryHardSudoku() {\r\n    while (true) {\r\n        let original = generateFullSudoku();\r\n        let hardSudoku = findHarderSudoku(original);\r\n        printSudoku(hardSudoku);\r\n        let solved = solveEasyMethods(hardSudoku);\r\n        if (!solved) {\r\n            return hardSudoku;\r\n        }\r\n    }\r\n}\r\n\r\n// Best effort returns a board filled in with all known values, otherwise nothing is returned for failed solves\r\nfunction solveEasyMethods(board, bestEffort) {\r\n    board = board.slice(0);\r\n    let possibilities = new Array(81);\r\n    for (let i = 0; i < 9*9; i++) {\r\n        possibilities[i] = new Set();\r\n        if (board[i] !== '-') {\r\n            possibilities[i].add(board[i]);\r\n        } else {\r\n            for (let j = 1; j <= 9; j++) {\r\n                possibilities[i].add(j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // generate value subsets\r\n    let valueSubsets = [];\r\n    let values = [1,2,3,4,5,6,7,8,9];\r\n    for (let i = 0; i < (1 << values.length); i++) {\r\n        let thisSet = new Set();\r\n        let curVal = i;\r\n        for (let j = 0; j < values.length; j++) {\r\n            if (curVal & 1) {\r\n                thisSet.add(values[j]);\r\n            }\r\n            curVal = curVal >> 1;\r\n        }\r\n        if (thisSet.size > 0 && thisSet.size < 5) {\r\n            valueSubsets.push(thisSet);\r\n        }\r\n    }\r\n\r\n    // generate sets of coordinates\r\n    let sets = [];\r\n    for (let i = 0; i < 9; i++) {\r\n        let rowset = [];\r\n        let colset = [];\r\n        for (let j = 0; j < 9; j++) {\r\n            rowset.push(i + j*9);\r\n            colset.push(j + i*9);\r\n        }\r\n        sets.push(rowset, colset);\r\n    }\r\n    for (let x = 0; x < 3; x++) {\r\n        for (let y = 0; y < 3; y++) {\r\n            let boxset = [];\r\n            for (let xx = 0; xx < 3; xx++) {\r\n                for (let yy = 0; yy < 3; yy++) {\r\n                    boxset.push((x*3+xx) + (y*3+yy)*9);\r\n                }\r\n            }\r\n            sets.push(boxset);\r\n        }\r\n    }\r\n\r\n    let didSomething = true;\r\n    while (didSomething) {\r\n        didSomething = false;\r\n        // check for n values appearing in n squares per set up to n=4, remove those from the rest of the set\r\n        // for each set\r\n        for (let group of sets) {\r\n            // for each subset of values\r\n            for (let valueSubset of valueSubsets) {\r\n                // naked subsets\r\n                // count which squares contain nothing but these values\r\n                if (valueSubset.size < 5) {\r\n                    let squaresContainingOnly = new Set();\r\n                    for (let square of group) {\r\n                        let hasExtraValue = false;\r\n                        for (let value of possibilities[square]) {\r\n\r\n                            if (!valueSubset.has(value)) {\r\n                                hasExtraValue = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!hasExtraValue) {\r\n                            squaresContainingOnly.add(square);\r\n                        }   \r\n                    }\r\n                    // if #squares === #values\r\n                    if (squaresContainingOnly.size === valueSubset.size) {\r\n                        // remove values from all other squares\r\n                        for (let square of group) {\r\n                            if (!squaresContainingOnly.has(square)) {\r\n                                for (let value of valueSubset) {\r\n                                    if (possibilities[square].has(value)) {\r\n                                        didSomething = true;\r\n                                    }\r\n                                    possibilities[square].delete(value);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (valueSubset.size < 5) {\r\n                    // hidden subsets\r\n                    // count which squares contain at least some of the values\r\n                    let squaresContainingSome = new Set();\r\n                    for (let square of group) {\r\n                        let missingValue = false;\r\n                        let hasOne = false;\r\n                        for (let value of valueSubset) {\r\n                            if (!possibilities[square].has(value)) {\r\n                                missingValue = true;\r\n                            } else {\r\n                                hasOne = true;\r\n                            }\r\n                        }\r\n                        if (hasOne) {\r\n                            squaresContainingSome.add(square);\r\n                        }\r\n                    }\r\n                    // if #squares === #values\r\n                    if (squaresContainingSome.size === valueSubset.size) {\r\n                        // remove other values from these squares\r\n                        for (let square of squaresContainingSome) {\r\n                            let newSet = new Set();\r\n                            for (let value of valueSubset) {\r\n                                if (possibilities[square].has(value)) {\r\n                                    newSet.add(value);\r\n                                }\r\n                            }\r\n                            if (possibilities[square].size !== newSet.size) {\r\n                                didSomething = true;\r\n                            }\r\n                            possibilities[square] = newSet;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < possibilities.length; i++) {\r\n        if (!bestEffort) {\r\n            if (possibilities[i].size !== 1) {\r\n                console.log('Failed to solve');\r\n                return;\r\n            }\r\n        }\r\n        if (possibilities[i].size !== 1) {\r\n            board[i] = '-';\r\n        } else {\r\n            board[i] = possibilities[i].values().next().value;\r\n        }\r\n    }\r\n    return board;\r\n}\r\n\r\n// count number of digits in sudoku\r\nfunction numNumbers(grid) {\r\n    let cnt = 0;\r\n    for (let i = 0; i < grid.length; i++) {\r\n        if (grid[i] !== '-') {\r\n            cnt++;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\n// generate a random filled sudoku with no blanks\r\nfunction generateFullSudoku() {\r\n    let grid = new Array(9*9);\r\n    grid.fill('-')\r\n    return solveSudoku(grid, false);\r\n}\r\n\r\n// given a sudoku, find a minimal sudoku guaranteed to be at least as hard as the original\r\nfunction findHarderSudoku(grid) {\r\n    grid = grid.slice(0);\r\n    const checkedMap = new Map();\r\n    for (let j = 0; j < 10000; j++) {\r\n        let i = Math.floor(Math.random() * 9*9);\r\n        if (checkedMap.has(i)) {\r\n            continue;\r\n        }\r\n        checkedMap.set(i, true);\r\n        console.log(checkedMap.size);\r\n        if (grid[i] === '-') {\r\n            continue;\r\n        }\r\n        let val = grid[i];\r\n        grid[i] = '-';\r\n        if (!hasMultiSolutions(grid)) {\r\n            continue;\r\n        }\r\n        grid[i] = val;\r\n    }\r\n    return grid;\r\n}\r\n\r\n// Only remove 40 values, so probably an easy to solve sudoku but this is not guaranteed, just for testing\r\nfunction findEasySudoku(grid) {\r\n    grid = grid.slice(0);\r\n    const checkedMap = new Map();\r\n    for (let j = 0; j < 40; j++) {\r\n        let i = Math.floor(Math.random() * 9*9);\r\n        if (checkedMap.has(i)) {\r\n            continue;\r\n        }\r\n        checkedMap.set(i, true);\r\n        console.log(checkedMap.size);\r\n        if (grid[i] === '-') {\r\n            continue;\r\n        }\r\n        let val = grid[i];\r\n        grid[i] = '-';\r\n        if (!hasMultiSolutions(grid)) {\r\n            continue;\r\n        }\r\n        grid[i] = val;\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction printSudoku(grid) {\r\n    for (let i = 0; i < 9; i++) {\r\n        console.log(grid.slice(i*9, i*9+9).join(''));\r\n    }\r\n}\r\n\r\nfunction findNumSolutions(grid) {\r\n    solutionsFound = 0;\r\n    solveSudoku(grid, true);\r\n    return solutionsFound;\r\n}\r\n\r\n// check if sudoku has multiple solutions, stop after first 2 found\r\nfunction hasMultiSolutions(grid) {\r\n    grid = solveEasyMethods(grid, true);\r\n    solutionsFound = 0;\r\n    solveSudoku(grid, true, true);\r\n    return solutionsFound !== 1;\r\n}\r\n\r\n// solves sudoku, check for how many solutions, and only check for at most 2 solutions\r\nfunction solveSudoku(grid, multiSolution, max2Solutions) {\r\n    if (grid.length !== 9*9) {\r\n        return 'Incorrect size';\r\n    }\r\n\r\n    if (!isValidSudoku(grid)) {\r\n        return 'Invalid';\r\n    }\r\n\r\n    for (let i = 0; i < 9*9; i++) {\r\n        if (grid[i] === '-') {\r\n            const cloneGrid = grid.slice(0);\r\n            const offset = Math.floor(Math.random() * 9);\r\n            for (let j = 1; j <= 9; j++) {\r\n                cloneGrid[i] = ((j + offset) % 9) + 1;\r\n                let solved = solveSudoku(cloneGrid, multiSolution, max2Solutions);\r\n                if (solved !== 'Invalid' && (!multiSolution || (multiSolution && max2Solutions && solutionsFound >= 2))) {\r\n                    return solved;\r\n                }\r\n            }\r\n            return 'Invalid';\r\n        }\r\n    }\r\n    if (multiSolution) {\r\n        solutionsFound++;\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction resetMap() {\r\n    curNumDedup = new Array(10);\r\n}\r\n\r\nfunction checkValue(val) {\r\n    if (val === '-') {\r\n        return true;\r\n    }\r\n    if (curNumDedup[val]) {\r\n        return false;\r\n    }\r\n    curNumDedup[val] = true;\r\n    return true;\r\n}\r\n\r\n// check that sudoku has valid filled in values (no conflicting numbers)\r\nfunction isValidSudoku(grid) {\r\n    for (let i = 0; i < 9; i++) {\r\n        resetMap();\r\n        for (let j = 0; j < 9; j++) {\r\n            if (!checkValue(grid[i*9+j])) {\r\n                return false;\r\n            }\r\n        }\r\n        resetMap();\r\n        for (let j = 0; j < 9; j++) {\r\n            if (!checkValue(grid[j*9+i])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    for (let x = 0; x < 3; x++) {\r\n        for (let y = 0; y < 3; y++) {\r\n            resetMap();\r\n            for (let u = 0; u < 3; u++) {\r\n                for (let v = 0; v < 3; v++) {\r\n                    if (!checkValue(grid[x*3 + u + (y*3 + v)*9])) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","import './App.css';\nimport Sudoku from './Sudoku';\nimport React from 'react';\nimport {generateVeryHardSudoku} from './utils';\n\nclass App extends React.Component {\n  constructor() {\n    super();\n\n    let empty = new Array(81);\n    empty.fill('-');\n    this.state = {\n      loading: false,\n      board: empty,\n    };\n  }\n  generateNewSudoku() {\n    let empty = new Array(81);\n    empty.fill('-');\n    this.setState({loading: true, board: empty});\n    setTimeout(() => {\n      let sudoku = generateVeryHardSudoku();\n      this.setState({board: sudoku, loading: false});\n    }, 100);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Very Hard Sudoku Generator</h1>\n        <Sudoku board={this.state.board}></Sudoku>\n        <div>\n          <button onClick={()=>this.generateNewSudoku()}>Generate New Sudoku</button>\n          {\n            this.state.loading ?\n            <div style={{\n              display: 'inline-block',\n              position: 'relative',\n              top: 5,\n              left: 5,\n            }}>\n              <div className=\"loader\"></div>\n            </div>\n            : null\n          }\n        </div>\n        <div style={{\n          width: 800,\n          marginLeft: 'auto',\n          marginRight: 'auto',\n        }}>\n        <h2>How does it work?</h2>\n        <p>\n          There are three stages to this sudoku generation algorithm.\n        </p>\n        <ol style={{display: 'table', margin: 'auto', textAlign: 'left'}}>\n          <li>Generate Solved Sudoku</li>\n          <li>Remove elements until the sudoku is both <a href=\"https://en.wikipedia.org/wiki/Mathematics_of_Sudoku#Overview\">proper and minimal</a></li>\n          <li>If basic solving techniques can solve the sudoku, discard the sudoku and start from step 1.</li>\n        </ol>\n        <p>\n          In the first stage a solved sudoku is generated. This is done by randomly filling in valid sudoku values in empty squares and\n          backtracking when a valid value can no longer be filled in.\n        </p>\n        <p>\n          In the second stage, values are removed from the solved sudoku randomly. After each value is removed, the sudoku is solved by a brute force solver which also checks for multiple solutions.\n          If removing a value leads to multiple solutions, the value is placed back in the sudoku and a different square is selected to be removed. After this stage is complete, no number can be removed\n          without allowing for an ambiguous solution so the sudoku is called a minimal sudoku. Minimal sudokus do not have many numbers but this does not necessarily make them hard. To ensure the sudoku\n          is difficult, a third stage is necessary.\n        </p>\n        <p>\n          The final stage runs the generated sudoku from the previous steps through a constraint propagation based solving algorithm which mimics the most common human solving strategies. If the\n          sudoku can be solved with this algorithm then it is discarded and the process repeats until a sudoku that cannot be solved with constraint propagation is generated.\n        </p>\n        <h2>More on constraint propagation</h2>\n        <p>\n          The constraint propagation I implemented only looks for <a href=\"https://www.learn-sudoku.com/basic-techniques.html\">hidden subsets (up to 4) and naked subsets (up to 4)</a>.\n          This seems to be enough to solve many human generated sudokus even many of those rated \"hard\" or \"expert\" (although that is subjective). The purpose of this\n          algorithm is not to solve all sudokus but rather to attempt to solve them only using a restricted set of logical rules. If the sudoku cannot be solved using these\n          rules then it must require a more advanced trick. I implemented a custom algorithm for this based on the first part of Peter Norvig's page <a href=\"https://norvig.com/sudoku.html\">Solving Every Sudoku Puzzle</a>. Eliminating sudokus that are solved with this method ensures that any\n          sudoku generated at some point requires the use of a more advanced technique like <a href=\"https://www.learn-sudoku.com/advanced-techniques.html\">X-Wing or Swordfish</a>. Some\n          of the generated sudokus seem to require completely custom logic tricks as well which can make them more interesting.\n        </p>\n        </div>\n        <a style={{\n          color: 'grey',\n          position: 'fixed',\n          right: 10,\n          bottom: 10,\n        }}\n        href=\"https://natethegreat2525.github.io/\">Nathan's Projects</a>\n      </div>\n  );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}