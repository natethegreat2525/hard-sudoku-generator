[{"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\index.js":"1","C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\App.js":"2","C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\reportWebVitals.js":"3","C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\Sudoku.js":"4","C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\utils.js":"5"},{"size":500,"mtime":499162500000,"results":"6","hashOfConfig":"7"},{"size":4568,"mtime":1611018260789,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":499162500000,"results":"9","hashOfConfig":"7"},{"size":1803,"mtime":1609830652877,"results":"10","hashOfConfig":"7"},{"size":10459,"mtime":1609828251728,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1itt26m",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"24"},"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\index.js",[],["25","26"],"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\App.js",[],"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\reportWebVitals.js",[],"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\Sudoku.js",[],"C:\\Users\\Nathan\\programming\\js\\sudoku\\hard-sudoku\\src\\utils.js",["27","28","29","30"],"let curNumDedup = null;\r\nlet solutionsFound = 0;\r\n\r\nexport function generateVeryHardSudoku() {\r\n    while (true) {\r\n        let original = generateFullSudoku();\r\n        let hardSudoku = findHarderSudoku(original);\r\n        printSudoku(hardSudoku);\r\n        let solved = solveEasyMethods(hardSudoku);\r\n        if (!solved) {\r\n            return hardSudoku;\r\n        }\r\n    }\r\n}\r\n\r\n// Best effort returns a board filled in with all known values, otherwise nothing is returned for failed solves\r\nfunction solveEasyMethods(board, bestEffort) {\r\n    board = board.slice(0);\r\n    let possibilities = new Array(81);\r\n    for (let i = 0; i < 9*9; i++) {\r\n        possibilities[i] = new Set();\r\n        if (board[i] !== '-') {\r\n            possibilities[i].add(board[i]);\r\n        } else {\r\n            for (let j = 1; j <= 9; j++) {\r\n                possibilities[i].add(j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // generate value subsets\r\n    let valueSubsets = [];\r\n    let values = [1,2,3,4,5,6,7,8,9];\r\n    for (let i = 0; i < (1 << values.length); i++) {\r\n        let thisSet = new Set();\r\n        let curVal = i;\r\n        for (let j = 0; j < values.length; j++) {\r\n            if (curVal & 1) {\r\n                thisSet.add(values[j]);\r\n            }\r\n            curVal = curVal >> 1;\r\n        }\r\n        if (thisSet.size > 0 && thisSet.size < 5) {\r\n            valueSubsets.push(thisSet);\r\n        }\r\n    }\r\n\r\n    // generate sets of coordinates\r\n    let sets = [];\r\n    for (let i = 0; i < 9; i++) {\r\n        let rowset = [];\r\n        let colset = [];\r\n        for (let j = 0; j < 9; j++) {\r\n            rowset.push(i + j*9);\r\n            colset.push(j + i*9);\r\n        }\r\n        sets.push(rowset, colset);\r\n    }\r\n    for (let x = 0; x < 3; x++) {\r\n        for (let y = 0; y < 3; y++) {\r\n            let boxset = [];\r\n            for (let xx = 0; xx < 3; xx++) {\r\n                for (let yy = 0; yy < 3; yy++) {\r\n                    boxset.push((x*3+xx) + (y*3+yy)*9);\r\n                }\r\n            }\r\n            sets.push(boxset);\r\n        }\r\n    }\r\n\r\n    let didSomething = true;\r\n    while (didSomething) {\r\n        didSomething = false;\r\n        // check for n values appearing in n squares per set up to n=4, remove those from the rest of the set\r\n        // for each set\r\n        for (let group of sets) {\r\n            // for each subset of values\r\n            for (let valueSubset of valueSubsets) {\r\n                // naked subsets\r\n                // count which squares contain nothing but these values\r\n                if (valueSubset.size < 5) {\r\n                    let squaresContainingOnly = new Set();\r\n                    for (let square of group) {\r\n                        let hasExtraValue = false;\r\n                        for (let value of possibilities[square]) {\r\n\r\n                            if (!valueSubset.has(value)) {\r\n                                hasExtraValue = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!hasExtraValue) {\r\n                            squaresContainingOnly.add(square);\r\n                        }   \r\n                    }\r\n                    // if #squares === #values\r\n                    if (squaresContainingOnly.size === valueSubset.size) {\r\n                        // remove values from all other squares\r\n                        for (let square of group) {\r\n                            if (!squaresContainingOnly.has(square)) {\r\n                                for (let value of valueSubset) {\r\n                                    if (possibilities[square].has(value)) {\r\n                                        didSomething = true;\r\n                                    }\r\n                                    possibilities[square].delete(value);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (valueSubset.size < 5) {\r\n                    // hidden subsets\r\n                    // count which squares contain at least some of the values\r\n                    let squaresContainingSome = new Set();\r\n                    for (let square of group) {\r\n                        let missingValue = false;\r\n                        let hasOne = false;\r\n                        for (let value of valueSubset) {\r\n                            if (!possibilities[square].has(value)) {\r\n                                missingValue = true;\r\n                            } else {\r\n                                hasOne = true;\r\n                            }\r\n                        }\r\n                        if (hasOne) {\r\n                            squaresContainingSome.add(square);\r\n                        }\r\n                    }\r\n                    // if #squares === #values\r\n                    if (squaresContainingSome.size === valueSubset.size) {\r\n                        // remove other values from these squares\r\n                        for (let square of squaresContainingSome) {\r\n                            let newSet = new Set();\r\n                            for (let value of valueSubset) {\r\n                                if (possibilities[square].has(value)) {\r\n                                    newSet.add(value);\r\n                                }\r\n                            }\r\n                            if (possibilities[square].size !== newSet.size) {\r\n                                didSomething = true;\r\n                            }\r\n                            possibilities[square] = newSet;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < possibilities.length; i++) {\r\n        if (!bestEffort) {\r\n            if (possibilities[i].size !== 1) {\r\n                console.log('Failed to solve');\r\n                return;\r\n            }\r\n        }\r\n        if (possibilities[i].size !== 1) {\r\n            board[i] = '-';\r\n        } else {\r\n            board[i] = possibilities[i].values().next().value;\r\n        }\r\n    }\r\n    return board;\r\n}\r\n\r\n// count number of digits in sudoku\r\nfunction numNumbers(grid) {\r\n    let cnt = 0;\r\n    for (let i = 0; i < grid.length; i++) {\r\n        if (grid[i] !== '-') {\r\n            cnt++;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\n// generate a random filled sudoku with no blanks\r\nfunction generateFullSudoku() {\r\n    let grid = new Array(9*9);\r\n    grid.fill('-')\r\n    return solveSudoku(grid, false);\r\n}\r\n\r\n// given a sudoku, find a minimal sudoku guaranteed to be at least as hard as the original\r\nfunction findHarderSudoku(grid) {\r\n    grid = grid.slice(0);\r\n    const checkedMap = new Map();\r\n    for (let j = 0; j < 10000; j++) {\r\n        let i = Math.floor(Math.random() * 9*9);\r\n        if (checkedMap.has(i)) {\r\n            continue;\r\n        }\r\n        checkedMap.set(i, true);\r\n        console.log(checkedMap.size);\r\n        if (grid[i] === '-') {\r\n            continue;\r\n        }\r\n        let val = grid[i];\r\n        grid[i] = '-';\r\n        if (!hasMultiSolutions(grid)) {\r\n            continue;\r\n        }\r\n        grid[i] = val;\r\n    }\r\n    return grid;\r\n}\r\n\r\n// Only remove 40 values, so probably an easy to solve sudoku but this is not guaranteed, just for testing\r\nfunction findEasySudoku(grid) {\r\n    grid = grid.slice(0);\r\n    const checkedMap = new Map();\r\n    for (let j = 0; j < 40; j++) {\r\n        let i = Math.floor(Math.random() * 9*9);\r\n        if (checkedMap.has(i)) {\r\n            continue;\r\n        }\r\n        checkedMap.set(i, true);\r\n        console.log(checkedMap.size);\r\n        if (grid[i] === '-') {\r\n            continue;\r\n        }\r\n        let val = grid[i];\r\n        grid[i] = '-';\r\n        if (!hasMultiSolutions(grid)) {\r\n            continue;\r\n        }\r\n        grid[i] = val;\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction printSudoku(grid) {\r\n    for (let i = 0; i < 9; i++) {\r\n        console.log(grid.slice(i*9, i*9+9).join(''));\r\n    }\r\n}\r\n\r\nfunction findNumSolutions(grid) {\r\n    solutionsFound = 0;\r\n    solveSudoku(grid, true);\r\n    return solutionsFound;\r\n}\r\n\r\n// check if sudoku has multiple solutions, stop after first 2 found\r\nfunction hasMultiSolutions(grid) {\r\n    grid = solveEasyMethods(grid, true);\r\n    solutionsFound = 0;\r\n    solveSudoku(grid, true, true);\r\n    return solutionsFound !== 1;\r\n}\r\n\r\n// solves sudoku, check for how many solutions, and only check for at most 2 solutions\r\nfunction solveSudoku(grid, multiSolution, max2Solutions) {\r\n    if (grid.length !== 9*9) {\r\n        return 'Incorrect size';\r\n    }\r\n\r\n    if (!isValidSudoku(grid)) {\r\n        return 'Invalid';\r\n    }\r\n\r\n    for (let i = 0; i < 9*9; i++) {\r\n        if (grid[i] === '-') {\r\n            const cloneGrid = grid.slice(0);\r\n            const offset = Math.floor(Math.random() * 9);\r\n            for (let j = 1; j <= 9; j++) {\r\n                cloneGrid[i] = ((j + offset) % 9) + 1;\r\n                let solved = solveSudoku(cloneGrid, multiSolution, max2Solutions);\r\n                if (solved !== 'Invalid' && (!multiSolution || (multiSolution && max2Solutions && solutionsFound >= 2))) {\r\n                    return solved;\r\n                }\r\n            }\r\n            return 'Invalid';\r\n        }\r\n    }\r\n    if (multiSolution) {\r\n        solutionsFound++;\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction resetMap() {\r\n    curNumDedup = new Array(10);\r\n}\r\n\r\nfunction checkValue(val) {\r\n    if (val === '-') {\r\n        return true;\r\n    }\r\n    if (curNumDedup[val]) {\r\n        return false;\r\n    }\r\n    curNumDedup[val] = true;\r\n    return true;\r\n}\r\n\r\n// check that sudoku has valid filled in values (no conflicting numbers)\r\nfunction isValidSudoku(grid) {\r\n    for (let i = 0; i < 9; i++) {\r\n        resetMap();\r\n        for (let j = 0; j < 9; j++) {\r\n            if (!checkValue(grid[i*9+j])) {\r\n                return false;\r\n            }\r\n        }\r\n        resetMap();\r\n        for (let j = 0; j < 9; j++) {\r\n            if (!checkValue(grid[j*9+i])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    for (let x = 0; x < 3; x++) {\r\n        for (let y = 0; y < 3; y++) {\r\n            resetMap();\r\n            for (let u = 0; u < 3; u++) {\r\n                for (let v = 0; v < 3; v++) {\r\n                    if (!checkValue(grid[x*3 + u + (y*3 + v)*9])) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}",["31","32"],{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","severity":1,"message":"38","line":121,"column":33,"nodeType":"39","messageId":"40","endLine":121,"endColumn":45},{"ruleId":"37","severity":1,"message":"41","line":168,"column":10,"nodeType":"39","messageId":"40","endLine":168,"endColumn":20},{"ruleId":"37","severity":1,"message":"42","line":210,"column":10,"nodeType":"39","messageId":"40","endLine":210,"endColumn":24},{"ruleId":"37","severity":1,"message":"43","line":239,"column":10,"nodeType":"39","messageId":"40","endLine":239,"endColumn":26},{"ruleId":"33","replacedBy":"44"},{"ruleId":"35","replacedBy":"45"},"no-native-reassign",["46"],"no-negated-in-lhs",["47"],"no-unused-vars","'missingValue' is assigned a value but never used.","Identifier","unusedVar","'numNumbers' is defined but never used.","'findEasySudoku' is defined but never used.","'findNumSolutions' is defined but never used.",["46"],["47"],"no-global-assign","no-unsafe-negation"]